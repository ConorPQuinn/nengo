

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Nengo Modelling API &#8212; Nengo core 2.6.0 docs</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Setting parameters with Configs" href="config.html" />
    <link rel="prev" title="User Guide" href="user_guide.html" />
<link rel="stylesheet" type="text/css" href="_static/custom.css">


  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="config.html" title="Setting parameters with Configs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="user_guide.html" title="User Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.6.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" accesskey="U">User Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
        <a href="
    index.html" class="text-logo">Nengo core 2.6</a>
        <div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="user_guide.html">User Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nengo Modelling API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nengo-objects">Nengo Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributions">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#neuron-types">Neuron types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#learning-rule-types">Learning rule types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processes">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synapse-models">Synapse models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decoder-and-connection-weight-solvers">Decoder and connection weight solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Setting parameters with Configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="spa.html">Semantic Pointer Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html">Advanced topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="backend_api.html">Reference simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html">Release History</a></li>
<li class="toctree-l2"><a class="reference internal" href="history.html">Nengo history</a></li>
<li class="toctree-l2"><a class="reference internal" href="converting.html">Converting from Nengo 1.4 to Nengo 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dev_guide.html">Developer Guide</a></li>
</ul>

    
  </div>
</div>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html">Docs</a></li>
              
                <li><a href="user_guide.html">User Guide</a></li>
              
              <li>Nengo Modelling API</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="nengo-modelling-api">
<h1>Nengo Modelling API<a class="headerlink" href="#nengo-modelling-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="nengo-objects">
<h2>Nengo Objects<a class="headerlink" href="#nengo-objects" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Network</span></code></a></td>
<td>A network contains ensembles, nodes, connections, and other networks.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Ensemble</span></code></a></td>
<td>A group of neurons that collectively represent a vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal"><span class="pre">nengo.ensemble.Neurons</span></code></a></td>
<td>An interface for making connections directly to an ensemble’s neurons.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Node</span></code></a></td>
<td>Provide non-neural inputs to Nengo objects and process outputs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Connection</span></code></a></td>
<td>Connects two objects together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.connection.LearningRule" title="nengo.connection.LearningRule"><code class="xref py py-obj docutils literal"><span class="pre">nengo.connection.LearningRule</span></code></a></td>
<td>An interface for making connections to a learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Probe</span></code></a></td>
<td>A probe is an object that collects data from the simulation.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Network">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Network</code><span class="sig-paren">(</span><em>label=None</em>, <em>seed=None</em>, <em>add_to_container=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A network contains ensembles, nodes, connections, and other networks.</p>
<p>A network is primarily used for grouping together related
objects and connections for visualization purposes.
However, you can also use networks as a nice way to reuse
network creation code.</p>
<p>To group together related objects that you do not need to reuse,
you can create a new <code class="docutils literal"><span class="pre">Network</span></code> and add objects in a <code class="docutils literal"><span class="pre">with</span></code> block.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Vision&quot;</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Motor&quot;</span><span class="p">):</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
</pre></div>
</div>
<p>To reuse a group of related objects, you can create a new subclass
of <code class="docutils literal"><span class="pre">Network</span></code>, and add objects in the <code class="docutils literal"><span class="pre">__init__</span></code> method.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OcularDominance</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="n">left_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">right_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">left_eye</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">right_eye</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>label</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>Name of the network.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>Random number seed that will be fed to the random number generator.
Setting the seed makes the network’s build process deterministic.</p>
</div></blockquote>
<p><strong>add_to_container</strong> : bool, optional (Default: None)</p>
<blockquote class="last">
<div><p>Determines if this network will be added to the current container.
If None, this network will be added to the network at the top of the
<code class="docutils literal"><span class="pre">Network.context</span></code> stack unless the stack is empty.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>connections</strong></td>
<td>(list) <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> instances in this network.</td>
</tr>
<tr class="row-odd"><td><strong>ensembles</strong></td>
<td>(list) <a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">Ensemble</span></code></a> instances in this network.</td>
</tr>
<tr class="row-even"><td><strong>label</strong></td>
<td>(str) Name of this network.</td>
</tr>
<tr class="row-odd"><td><strong>networks</strong></td>
<td>(list) <a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">Network</span></code></a> instances in this network.</td>
</tr>
<tr class="row-even"><td><strong>nodes</strong></td>
<td>(list) <a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal"><span class="pre">Node</span></code></a> instances in this network.</td>
</tr>
<tr class="row-odd"><td><strong>probes</strong></td>
<td>(list) <a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal"><span class="pre">Probe</span></code></a> instances in this network.</td>
</tr>
<tr class="row-even"><td><strong>seed</strong></td>
<td>(int) Random seed used by this network.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="nengo.Network.add">
<em class="property">static </em><code class="descname">add</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the passed object to <code class="docutils literal"><span class="pre">Network.context</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nengo.Network.default_config">
<em class="property">static </em><code class="descname">default_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.default_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.default_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal"><span class="pre">Config</span></code></a> object for setting defaults.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_objects">
<code class="descname">all_objects</code><a class="headerlink" href="#nengo.Network.all_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All objects in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_ensembles">
<code class="descname">all_ensembles</code><a class="headerlink" href="#nengo.Network.all_ensembles" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All ensembles in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_nodes">
<code class="descname">all_nodes</code><a class="headerlink" href="#nengo.Network.all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All nodes in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_networks">
<code class="descname">all_networks</code><a class="headerlink" href="#nengo.Network.all_networks" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All networks in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_connections">
<code class="descname">all_connections</code><a class="headerlink" href="#nengo.Network.all_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All connections in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_probes">
<code class="descname">all_probes</code><a class="headerlink" href="#nengo.Network.all_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All probes in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.config">
<code class="descname">config</code><a class="headerlink" href="#nengo.Network.config" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal"><span class="pre">Config</span></code></a>) Configuration for this network.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.n_neurons">
<code class="descname">n_neurons</code><a class="headerlink" href="#nengo.Network.n_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Number of neurons in this network, including subnetworks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Ensemble">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Ensemble</code><span class="sig-paren">(</span><em>n_neurons</em>, <em>dimensions</em>, <em>radius=Default</em>, <em>encoders=Default</em>, <em>intercepts=Default</em>, <em>max_rates=Default</em>, <em>eval_points=Default</em>, <em>n_eval_points=Default</em>, <em>neuron_type=Default</em>, <em>gain=Default</em>, <em>bias=Default</em>, <em>noise=Default</em>, <em>normalize_encoders=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Ensemble"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>A group of neurons that collectively represent a vector.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>n_neurons</strong> : int</p>
<blockquote>
<div><p>The number of neurons.</p>
</div></blockquote>
<p><strong>dimensions</strong> : int</p>
<blockquote>
<div><p>The number of representational dimensions.</p>
</div></blockquote>
<p><strong>radius</strong> : int, optional (Default: 1.0)</p>
<blockquote>
<div><p>The representational radius of the ensemble.</p>
</div></blockquote>
<p><strong>encoders</strong> : Distribution or (n_neurons, dimensions) array_like, optional                (Default: UniformHypersphere(surface=True))</p>
<blockquote>
<div><p>The encoders used to transform from representational space
to neuron space. Each row is a neuron’s encoder; each column is a
representational dimension.</p>
</div></blockquote>
<p><strong>intercepts</strong> : Distribution or (n_neurons,) array_like, optional                  (Default: <code class="docutils literal"><span class="pre">nengo.dists.Uniform(-1.0,</span> <span class="pre">1.0)</span></code>)</p>
<blockquote>
<div><p>The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal"><span class="pre">c</span></code> is the given intercept.</p>
</div></blockquote>
<p><strong>max_rates</strong> : Distribution or (n_neurons,) array_like, optional                 (Default: <code class="docutils literal"><span class="pre">nengo.dists.Uniform(200,</span> <span class="pre">400)</span></code>)</p>
<blockquote>
<div><p>The activity of each neuron when the input signal <code class="docutils literal"><span class="pre">x</span></code> is magnitude 1
and aligned with that neuron’s encoder <code class="docutils literal"><span class="pre">e</span></code>;
i.e., when <code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</div></blockquote>
<p><strong>eval_points</strong> : Distribution or (n_eval_points, dims) array_like, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.dists.UniformHypersphere()</span></code>)</p>
<blockquote>
<div><p>The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</div></blockquote>
<p><strong>n_eval_points</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>The number of evaluation points to be drawn from the <code class="xref py py-obj docutils literal"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</div></blockquote>
<p><strong>neuron_type</strong> : <a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">NeuronType</span></code></a>, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.LIF()</span></code>)</p>
<blockquote>
<div><p>The model that simulates all neurons in the ensemble
(see <a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">NeuronType</span></code></a>).</p>
</div></blockquote>
<p><strong>gain</strong> : Distribution or (n_neurons,) array_like (Default: None)</p>
<blockquote>
<div><p>The gains associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal"><span class="pre">max_rates</span></code> and <code class="docutils literal"><span class="pre">intercepts</span></code>.</p>
</div></blockquote>
<p><strong>bias</strong> : Distribution or (n_neurons,) array_like (Default: None)</p>
<blockquote>
<div><p>The biases associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal"><span class="pre">max_rates</span></code> and <code class="docutils literal"><span class="pre">intercepts</span></code>.</p>
</div></blockquote>
<p><strong>noise</strong> : Process, optional (Default: None)</p>
<blockquote>
<div><p>Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</div></blockquote>
<p><strong>normalize_encoders</strong> : bool, optional (Default: True)</p>
<blockquote>
<div><p>Indicates whether the encoders should be normalized.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>A name for the ensemble. Used for debugging and visualization.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>The seed used for random number generation.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>bias</strong></td>
<td>(Distribution or (n_neurons,) array_like or None) The biases associated with each neuron in the ensemble.</td>
</tr>
<tr class="row-even"><td><strong>dimensions</strong></td>
<td>(int) The number of representational dimensions.</td>
</tr>
<tr class="row-odd"><td><strong>encoders</strong></td>
<td>(Distribution or (n_neurons, dimensions) array_like) The encoders, used to transform from representational space to neuron space. Each row is a neuron’s encoder, each column is a representational dimension.</td>
</tr>
<tr class="row-even"><td><strong>eval_points</strong></td>
<td>(Distribution or (n_eval_points, dims) array_like) The evaluation points used for decoder solving, spanning the interval (-radius, radius) in each dimension, or a distribution from which to choose evaluation points.</td>
</tr>
<tr class="row-odd"><td><strong>gain</strong></td>
<td>(Distribution or (n_neurons,) array_like or None) The gains associated with each neuron in the ensemble.</td>
</tr>
<tr class="row-even"><td><strong>intercepts</strong></td>
<td>(Distribution or (n_neurons) array_like or None) The point along each neuron’s encoder where its activity is zero. If <code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when <code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal"><span class="pre">c</span></code> is the given intercept.</td>
</tr>
<tr class="row-odd"><td><strong>label</strong></td>
<td>(str or None) A name for the ensemble. Used for debugging and visualization.</td>
</tr>
<tr class="row-even"><td><strong>max_rates</strong></td>
<td>(Distribution or (n_neurons,) array_like or None) The activity of each neuron when <code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>, where <code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder.</td>
</tr>
<tr class="row-odd"><td><strong>n_eval_points</strong></td>
<td>(int or None) The number of evaluation points to be drawn from the <code class="xref py py-obj docutils literal"><span class="pre">eval_points</span></code> distribution. If None, then a heuristic is used to determine the number of evaluation points.</td>
</tr>
<tr class="row-even"><td><strong>n_neurons</strong></td>
<td>(int or None) The number of neurons.</td>
</tr>
<tr class="row-odd"><td><strong>neuron_type</strong></td>
<td>(NeuronType) The model that simulates all neurons in the ensemble (see <code class="docutils literal"><span class="pre">nengo.neurons</span></code>).</td>
</tr>
<tr class="row-even"><td><strong>noise</strong></td>
<td>(Process or None) Random noise injected directly into each neuron in the ensemble as current. A sample is drawn for each individual neuron on every simulation step.</td>
</tr>
<tr class="row-odd"><td><strong>radius</strong></td>
<td>(int) The representational radius of the ensemble.</td>
</tr>
<tr class="row-even"><td><strong>seed</strong></td>
<td>(int or None) The seed used for random number generation.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Ensemble.neurons">
<code class="descname">neurons</code><a class="headerlink" href="#nengo.Ensemble.neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>A direct interface to the neurons in the ensemble.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Ensemble.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Ensemble.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Ensemble.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Ensemble.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.ensemble.Neurons">
<em class="property">class </em><code class="descclassname">nengo.ensemble.</code><code class="descname">Neurons</code><span class="sig-paren">(</span><em>ensemble</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.ensemble.Neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections directly to an ensemble’s neurons.</p>
<p>This should only ever be accessed through the <code class="docutils literal"><span class="pre">neurons</span></code> attribute of an
ensemble, as a way to signal to <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> that the connection
should be made directly to the neurons rather than to the ensemble’s
decoded value, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="nengo.ensemble.Neurons.ensemble">
<code class="descname">ensemble</code><a class="headerlink" href="#nengo.ensemble.Neurons.ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>(Ensemble) The ensemble these neurons are part of.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.probeable">
<code class="descname">probeable</code><a class="headerlink" href="#nengo.ensemble.Neurons.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the neuron population.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Node">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>output=Default</em>, <em>size_in=Default</em>, <em>size_out=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/node.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide non-neural inputs to Nengo objects and process outputs.</p>
<p>Nodes can accept input, and perform arbitrary computations
for the purpose of controlling a Nengo simulation.
Nodes are typically not part of a brain model per se,
but serve to summarize the assumptions being made
about sensory data or other environment variables
that cannot be generated by a brain model alone.</p>
<p>Nodes can also be used to test models by providing specific input signals
to parts of the model, and can simplify the input/output interface of a
<a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">Network</span></code></a> when used as a relay to/from its internal
ensembles (see <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray</span></code></a> for an example).</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>output</strong> : callable, array_like, or None</p>
<blockquote>
<div><p>Function that transforms the Node inputs into outputs,
a constant output value, or None to transmit signals unchanged.</p>
</div></blockquote>
<p><strong>size_in</strong> : int, optional (Default: 0)</p>
<blockquote>
<div><p>The number of dimensions of the input data parameter.</p>
</div></blockquote>
<p><strong>size_out</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>The size of the output signal. If None, it will be determined
based on the values of <code class="docutils literal"><span class="pre">output</span></code> and <code class="docutils literal"><span class="pre">size_in</span></code>.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>A name for the node. Used for debugging and visualization.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>The seed used for random number generation.
Note: no aspects of the node are random, so currently setting
this seed has no effect.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>label</strong></td>
<td>(str) The name of the node.</td>
</tr>
<tr class="row-even"><td><strong>output</strong></td>
<td>(callable, array_like, or None) The given output.</td>
</tr>
<tr class="row-odd"><td><strong>size_in</strong></td>
<td>(int) The number of dimensions for incoming connection.</td>
</tr>
<tr class="row-even"><td><strong>size_out</strong></td>
<td>(int) The number of output dimensions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Connection">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Connection</code><span class="sig-paren">(</span><em>pre</em>, <em>post</em>, <em>synapse=Default</em>, <em>function=Default</em>, <em>transform=Default</em>, <em>solver=Default</em>, <em>learning_rule_type=Default</em>, <em>eval_points=Default</em>, <em>scale_eval_points=Default</em>, <em>label=Default</em>, <em>seed=Default</em>, <em>modulatory=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects two objects together.</p>
<p>The connection between the two object is unidirectional,
transmitting information from the first argument, <code class="docutils literal"><span class="pre">pre</span></code>,
to the second argument, <code class="docutils literal"><span class="pre">post</span></code>.</p>
<p>Almost any Nengo object can act as the pre or post side of a connection.
Additionally, you can use Python slice syntax to access only some of the
dimensions of the pre or post object.</p>
<p>For example, if <code class="docutils literal"><span class="pre">node</span></code> has <code class="docutils literal"><span class="pre">size_out=2</span></code> and <code class="docutils literal"><span class="pre">ensemble</span></code> has
<code class="docutils literal"><span class="pre">size_in=1</span></code>, we could not create the following connection:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<p>But, we could create either of these two connections:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
<span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>pre</strong> : Ensemble or Neurons or Node</p>
<blockquote>
<div><p>The source Nengo object for the connection.</p>
</div></blockquote>
<p><strong>post</strong> : Ensemble or Neurons or Node or Probe</p>
<blockquote>
<div><p>The destination object for the connection.</p>
</div></blockquote>
<p><strong>synapse</strong> : Synapse or None, optional               (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</p>
<blockquote>
<div><p>Synapse model to use for filtering (see <a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>).
If <em>None</em>, no synapse will be used and information will be transmitted
without any delay (if supported by the backend—some backends may
introduce a single time step delay).</p>
<p>Note that at least one connection must have a synapse that is not
<em>None</em> if components are connected in a cycle. Furthermore, a synaptic
filter with a zero time constant is different from a <em>None</em> synapse
as a synaptic filter will always add a delay of at least one time step.</p>
</div></blockquote>
<p><strong>function</strong> : callable or (n_eval_points, size_mid) array_like,                optional (Default: None)</p>
<blockquote>
<div><p>Function to compute across the connection. Note that <code class="docutils literal"><span class="pre">pre</span></code> must be
an ensemble to apply a function across the connection.
If an array is passed, the function is implicitly defined by the
points in the array and the provided <code class="docutils literal"><span class="pre">eval_points</span></code>, which have a
one-to-one correspondence.</p>
</div></blockquote>
<p><strong>transform</strong> : (size_out, size_mid) array_like, optional                 (Default: <code class="docutils literal"><span class="pre">np.array(1.0)</span></code>)</p>
<blockquote>
<div><p>Linear transform mapping the pre output to the post input.
This transform is in terms of the sliced size; if either pre
or post is a slice, the transform must be shaped according to
the sliced dimensionality. Additionally, the function is applied
before the transform, so if a function is computed across the
connection, the transform must be of shape <code class="docutils literal"><span class="pre">(size_out,</span> <span class="pre">size_mid)</span></code>.</p>
</div></blockquote>
<p><strong>solver</strong> : Solver, optional (Default: <code class="docutils literal"><span class="pre">nengo.solvers.LstsqL2()</span></code>)</p>
<blockquote>
<div><p>Solver instance to compute decoders or weights
(see <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a>). If <code class="docutils literal"><span class="pre">solver.weights</span></code> is True, a full
connection weight matrix is computed instead of decoders.</p>
</div></blockquote>
<p><strong>learning_rule_type</strong> : LearningRuleType or iterable of LearningRuleType,                          optional (Default: None)</p>
<blockquote>
<div><p>Modifies the decoders or connection weights during simulation.</p>
</div></blockquote>
<p><strong>eval_points</strong> : (n_eval_points, size_in) array_like or int, optional                   (Default: None)</p>
<blockquote>
<div><p>Points at which to evaluate <code class="docutils literal"><span class="pre">function</span></code> when computing decoders,
spanning the interval (-pre.radius, pre.radius) in each dimension.
If None, will use the eval_points associated with <code class="docutils literal"><span class="pre">pre</span></code>.</p>
</div></blockquote>
<p><strong>scale_eval_points</strong> : bool, optional (Default: True)</p>
<blockquote>
<div><p>Indicates whether the evaluation points should be scaled
by the radius of the pre Ensemble.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>A descriptive label for the connection.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>The seed used for random number generation.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>is_decoded</strong></td>
<td>(bool) True if and only if the connection is decoded. This will not occur when <code class="docutils literal"><span class="pre">solver.weights</span></code> is True or both pre and post are <a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal"><span class="pre">Neurons</span></code></a>.</td>
</tr>
<tr class="row-even"><td><strong>function</strong></td>
<td>(callable) The given function.</td>
</tr>
<tr class="row-odd"><td><strong>function_size</strong></td>
<td>(int) The output dimensionality of the given function. If no function is specified, function_size will be 0.</td>
</tr>
<tr class="row-even"><td><strong>label</strong></td>
<td>(str) A human-readable connection label for debugging and visualization. If not overridden, incorporates the labels of the pre and post objects.</td>
</tr>
<tr class="row-odd"><td><strong>learning_rule_type</strong></td>
<td>(instance or list or dict of LearningRuleType, optional) The learning rule types.</td>
</tr>
<tr class="row-even"><td><strong>post</strong></td>
<td>(Ensemble or Neurons or Node or Probe or ObjView) The given post object.</td>
</tr>
<tr class="row-odd"><td><strong>post_obj</strong></td>
<td>(Ensemble or Neurons or Node or Probe) The underlying post object, even if <code class="docutils literal"><span class="pre">post</span></code> is an <code class="docutils literal"><span class="pre">ObjView</span></code>.</td>
</tr>
<tr class="row-even"><td><strong>post_slice</strong></td>
<td>(slice or list or None) The slice associated with <code class="docutils literal"><span class="pre">post</span></code> if it is an ObjView, or None.</td>
</tr>
<tr class="row-odd"><td><strong>pre</strong></td>
<td>(Ensemble or Neurons or Node or ObjView) The given pre object.</td>
</tr>
<tr class="row-even"><td><strong>pre_obj</strong></td>
<td>(Ensemble or Neurons or Node) The underlying pre object, even if <code class="docutils literal"><span class="pre">post</span></code> is an <code class="docutils literal"><span class="pre">ObjView</span></code>.</td>
</tr>
<tr class="row-odd"><td><strong>pre_slice</strong></td>
<td>(slice or list or None) The slice associated with <code class="docutils literal"><span class="pre">pre</span></code> if it is an ObjView, or None.</td>
</tr>
<tr class="row-even"><td><strong>seed</strong></td>
<td>(int) The seed used for random number generation.</td>
</tr>
<tr class="row-odd"><td><strong>solver</strong></td>
<td>(Solver) The Solver instance that will be used to compute decoders or weights (see <code class="docutils literal"><span class="pre">nengo.solvers</span></code>).</td>
</tr>
<tr class="row-even"><td><strong>synapse</strong></td>
<td>(Synapse) The Synapse model used for filtering across the connection (see <code class="docutils literal"><span class="pre">nengo.synapses</span></code>).</td>
</tr>
<tr class="row-odd"><td><strong>transform</strong></td>
<td>((size_out, size_mid) array_like) Linear transform mapping the pre function output to the post input.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Connection.learning_rule">
<code class="descname">learning_rule</code><a class="headerlink" href="#nengo.Connection.learning_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>(LearningRule or iterable) Connectable learning rule object(s).</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Connection.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the pre object.</p>
<p>Also the input size of the function, if one is specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_mid">
<code class="descname">size_mid</code><a class="headerlink" href="#nengo.Connection.size_mid" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the function, if specified.</p>
<p>If the function is not specified, then <code class="docutils literal"><span class="pre">size_in</span> <span class="pre">==</span> <span class="pre">size_mid</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Connection.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of input dimensions of the post object.</p>
<p>Also the number of output dimensions of the transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.connection.LearningRule">
<em class="property">class </em><code class="descclassname">nengo.connection.</code><code class="descname">LearningRule</code><span class="sig-paren">(</span><em>connection</em>, <em>learning_rule_type</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#LearningRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.connection.LearningRule" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections to a learning rule.</p>
<p>Connections to a learning rule are to allow elements of the network to
affect the learning rule. For example, learning rules that use error
information can obtain that information through a connection.</p>
<p>Learning rule objects should only ever be accessed through the
<code class="docutils literal"><span class="pre">learning_rule</span></code> attribute of a connection.</p>
<dl class="attribute">
<dt id="nengo.connection.LearningRule.connection">
<code class="descname">connection</code><a class="headerlink" href="#nengo.connection.LearningRule.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>(Connection) The connection modified by the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.modifies">
<code class="descname">modifies</code><a class="headerlink" href="#nengo.connection.LearningRule.modifies" title="Permalink to this definition">¶</a></dt>
<dd><p>(str) The variable modified by the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.probeable">
<code class="descname">probeable</code><a class="headerlink" href="#nengo.connection.LearningRule.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.connection.LearningRule.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from learning rules, so always 0.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Probe">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Probe</code><span class="sig-paren">(</span><em>target</em>, <em>attr=None</em>, <em>sample_every=Default</em>, <em>synapse=Default</em>, <em>solver=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/probe.html#Probe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Probe" title="Permalink to this definition">¶</a></dt>
<dd><p>A probe is an object that collects data from the simulation.</p>
<p>This is to be used in any situation where you wish to gather simulation
data (spike data, represented values, neuron voltages, etc.) for analysis.</p>
<p>Probes do not directly affect the simulation.</p>
<p>All Nengo objects can be probed (except Probes themselves).
Each object has different attributes that can be probed.
To see what is probeable for each object, print its
<code class="docutils literal"><span class="pre">probeable</span></code> attribute.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">ens</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ens</span><span class="o">.</span><span class="n">probeable</span><span class="p">)</span>
<span class="go">[&#39;decoded_output&#39;, &#39;input&#39;]</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>target</strong> : Ensemble, Neurons, Node, or Connection</p>
<blockquote>
<div><p>The object to probe.</p>
</div></blockquote>
<p><strong>attr</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>The signal to probe. Refer to the target’s <code class="docutils literal"><span class="pre">probeable</span></code> list for
details. If None, the first element in the <code class="docutils literal"><span class="pre">probeable</span></code> list
will be used.</p>
</div></blockquote>
<p><strong>sample_every</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Sampling period in seconds. If None, the <code class="docutils literal"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</div></blockquote>
<p><strong>synapse</strong> : Synapse, optional (Default: None)</p>
<blockquote>
<div><p>A synaptic model to filter the probed signal.</p>
</div></blockquote>
<p><strong>solver</strong> : Solver, optional (Default: <code class="docutils literal"><span class="pre">ConnectionDefault</span></code>)</p>
<blockquote>
<div><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a> to compute decoders
for probes that require them.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional (Default: None)</p>
<blockquote>
<div><p>A name for the probe. Used for debugging and visualization.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>The seed used for random number generation.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>attr</strong></td>
<td>(str or None) The signal that will be probed. If None, the first element of the target’s <code class="docutils literal"><span class="pre">probeable</span></code> list will be used.</td>
</tr>
<tr class="row-odd"><td><strong>sample_every</strong></td>
<td>(float or None) Sampling period in seconds. If None, the <code class="docutils literal"><span class="pre">dt</span></code> of the simluation will be used.</td>
</tr>
<tr class="row-even"><td><strong>solver</strong></td>
<td>(Solver or None) <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a> to compute decoders. Only used for probes of an ensemble’s decoded output.</td>
</tr>
<tr class="row-odd"><td><strong>synapse</strong></td>
<td>(Synapse or None) A synaptic model to filter the probed signal.</td>
</tr>
<tr class="row-even"><td><strong>target</strong></td>
<td>(Ensemble, Neurons, Node, or Connection) The object to probe.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Probe.obj">
<code class="descname">obj</code><a class="headerlink" href="#nengo.Probe.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>(Nengo object) The underlying Nengo object target.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Probe.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Dimensionality of the probed signal.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Probe.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from probes, so always 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.slice">
<code class="descname">slice</code><a class="headerlink" href="#nengo.Probe.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>(slice) The slice associated with the Nengo object target.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Distribution</span></code></a></td>
<td>A base class for probability distributions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.get_samples" title="nengo.dists.get_samples"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.get_samples</span></code></a></td>
<td>Convenience function to sample a distribution or return samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Uniform" title="nengo.dists.Uniform"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Uniform</span></code></a></td>
<td>A uniform distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.Gaussian" title="nengo.dists.Gaussian"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Gaussian</span></code></a></td>
<td>A Gaussian distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Exponential" title="nengo.dists.Exponential"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Exponential</span></code></a></td>
<td>An exponential distribution (optionally with high values clipped).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.UniformHypersphere" title="nengo.dists.UniformHypersphere"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.UniformHypersphere</span></code></a></td>
<td>Uniform distribution on or in an n-dimensional unit hypersphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Choice" title="nengo.dists.Choice"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Choice</span></code></a></td>
<td>Discrete distribution across a set of possible values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.Samples" title="nengo.dists.Samples"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Samples</span></code></a></td>
<td>A set of samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.PDF" title="nengo.dists.PDF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.PDF</span></code></a></td>
<td>An arbitrary distribution from a PDF.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></td>
<td>Distribution of the square root of a Beta distributed random variable.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SubvectorLength</span></code></a></td>
<td>Distribution of the length of a subvectors of a unit vector.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.CosineSimilarity" title="nengo.dists.CosineSimilarity"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.CosineSimilarity</span></code></a></td>
<td>Distribution of the cosine of the angle between two random vectors.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.dists.Distribution">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Distribution</code><a class="reference internal" href="_modules/nengo/dists.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for probability distributions.</p>
<p>The only thing that a probabilities distribution need to define is a
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a> method. This base class ensures that all distributions
accept the same arguments for the sample function.</p>
<dl class="method">
<dt id="nengo.dists.Distribution.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>n</em>, <em>d=None</em>, <em>rng=np.random</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Distribution.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>n</strong> : int</p>
<blockquote>
<div><p>Number samples to take.</p>
</div></blockquote>
<p><strong>d</strong> : int or None, optional (Default: None)</p>
<blockquote>
<div><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal"><span class="pre">(n,)</span></code>.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a>, optional</p>
<blockquote>
<div><p>Random number generator state.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>samples</strong> : (n,) or (n, d) array_like</p>
<blockquote class="last">
<div><p>Samples as a 1d or 2d array depending on <code class="docutils literal"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.dists.get_samples">
<code class="descclassname">nengo.dists.</code><code class="descname">get_samples</code><span class="sig-paren">(</span><em>dist_or_samples</em>, <em>n</em>, <em>d=None</em>, <em>rng=np.random</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#get_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.get_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to sample a distribution or return samples.</p>
<p>Use this function in situations where you accept an argument that could
be a distribution, or could be an <code class="docutils literal"><span class="pre">array_like</span></code> of samples.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dist_or_samples</strong> : <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a> or (n, d) array_like</p>
<blockquote>
<div><p>Source of the samples to be returned.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number samples to take.</p>
</div></blockquote>
<p><strong>d</strong> : int or None, optional (Default: None)</p>
<blockquote>
<div><p>The number of dimensions to return.</p>
</div></blockquote>
<p><strong>rng</strong> : RandomState, optional (Default: np.random)</p>
<blockquote>
<div><p>Random number generator.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last"><strong>samples</strong> : (n, d) array_like</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">samples</span> <span class="o">=</span> <span class="n">get_samples</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">0.057277898442269548</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Uniform">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Uniform</code><span class="sig-paren">(</span><em>low</em>, <em>high</em>, <em>integer=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>A uniform distribution.</p>
<p>It’s equally likely to get any scalar between <code class="docutils literal"><span class="pre">low</span></code> and <code class="docutils literal"><span class="pre">high</span></code>.</p>
<p>Note that the order of <code class="docutils literal"><span class="pre">low</span></code> and <code class="docutils literal"><span class="pre">high</span></code> doesn’t matter;
if <code class="docutils literal"><span class="pre">low</span> <span class="pre">&lt;</span> <span class="pre">high</span></code> this will still work, and <code class="docutils literal"><span class="pre">low</span></code> will still
be a closed interval while <code class="docutils literal"><span class="pre">high</span></code> is open.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>low</strong> : Number</p>
<blockquote>
<div><p>The closed lower bound of the uniform distribution; samples &gt;= low</p>
</div></blockquote>
<p><strong>high</strong> : Number</p>
<blockquote>
<div><p>The open upper bound of the uniform distribution; samples &lt; high</p>
</div></blockquote>
<p><strong>integer</strong> : boolean, optional (Default: False)</p>
<blockquote class="last">
<div><p>If true, sample from a uniform distribution of integers. In this case,
low and high should be integers.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Gaussian">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>mean</em>, <em>std</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Gaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>A Gaussian distribution.</p>
<p>This represents a bell-curve centred at <code class="docutils literal"><span class="pre">mean</span></code> and with
spread represented by the standard deviation, <code class="docutils literal"><span class="pre">std</span></code>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>mean</strong> : Number</p>
<blockquote>
<div><p>The mean of the Gaussian.</p>
</div></blockquote>
<p><strong>std</strong> : Number</p>
<blockquote>
<div><p>The standard deviation of the Gaussian.</p>
</div></blockquote>
</dd>
<dt class="field-name">Raises</dt><dd class="field-body"><p class="first last"><strong>ValidationError if std is &lt;= 0</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Exponential">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>scale</em>, <em>shift=0.0</em>, <em>high=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Exponential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>An exponential distribution (optionally with high values clipped).</p>
<p>If <code class="docutils literal"><span class="pre">high</span></code> is left to its default value of infinity, this is a standard
exponential distribution. If <code class="docutils literal"><span class="pre">high</span></code> is set, then any sampled values at
or above <code class="docutils literal"><span class="pre">high</span></code> will be clipped so they are slightly below <code class="docutils literal"><span class="pre">high</span></code>.
This is useful for thresholding and, by extension,
<a class="reference internal" href="networks.html#nengo.networks.AssociativeMemory" title="nengo.networks.AssociativeMemory"><code class="xref py py-obj docutils literal"><span class="pre">networks.AssociativeMemory</span></code></a>.</p>
<p>The probability distribution function (PDF) is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">shift</span>
<span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="n">scale</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">shift</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">high</span>
       <span class="o">|</span>  <span class="n">n</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">high</span> <span class="o">-</span> <span class="n">eps</span>
       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">high</span>
</pre></div>
</div>
<p>where <code class="xref py py-obj docutils literal"><span class="pre">n</span></code> is such that the PDF integrates to one, and <code class="xref py py-obj docutils literal"><span class="pre">eps</span></code> is an
infintesimally small number such that samples of <code class="xref py py-obj docutils literal"><span class="pre">x</span></code> are strictly less than
<code class="xref py py-obj docutils literal"><span class="pre">high</span></code> (in practice, <code class="xref py py-obj docutils literal"><span class="pre">eps</span></code> depends on the floating point precision).</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>scale</strong> : float</p>
<blockquote>
<div><p>The scale parameter (inverse of the rate parameter lambda). Larger
values make the distribution narrower (sharper peak).</p>
</div></blockquote>
<p><strong>shift</strong> : float, optional (Default: 0)</p>
<blockquote>
<div><p>Amount to shift the distribution by. There will be no values smaller
than this shift when sampling from the distribution.</p>
</div></blockquote>
<p><strong>high</strong> : float, optional (Default: np.inf)</p>
<blockquote class="last">
<div><p>All values larger than or equal to this value will be clipped to
slightly less than this value.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.UniformHypersphere">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">UniformHypersphere</code><span class="sig-paren">(</span><em>surface=False</em>, <em>min_magnitude=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#UniformHypersphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p>
<p>Sample points are uniformly distibuted across the volume (default) or
surface of an n-dimensional unit hypersphere.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>surface</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>Whether sample points should be distributed uniformly
over the surface of the hyperphere (True),
or within the hypersphere (False).</p>
</div></blockquote>
<p><strong>min_magnitude</strong> : Number, optional (Default: 0)</p>
<blockquote class="last">
<div><p>Lower bound on the returned vector magnitudes (such that they are in
the range <code class="docutils literal"><span class="pre">[min_magnitude,</span> <span class="pre">1]</span></code>). Must be in the range [0, 1).
Ignored if <code class="docutils literal"><span class="pre">surface</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Choice">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Choice</code><span class="sig-paren">(</span><em>options</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Choice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete distribution across a set of possible values.</p>
<p>The same as <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.choice</span></code></a>, except can take vector or matrix values
for the choices.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>options</strong> : (N, …) array_like</p>
<blockquote>
<div><p>The options (choices) to choose between. The choice is always done
along the first axis, so if <code class="xref py py-obj docutils literal"><span class="pre">options</span></code> is a matrix, the options are
the rows of that matrix.</p>
</div></blockquote>
<p><strong>weights</strong> : (N,) array_like, optional (Default: None)</p>
<blockquote class="last">
<div><p>Weights controlling the probability of selecting each option. Will
automatically be normalized. If None, weights be uniformly distributed.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Samples">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Samples</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of samples.</p>
<p>This class is a subclass of <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a> so that it can be used in any
situation that calls for a  <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a>. However, the call to <a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a>
must match the dimensions of the samples or a <code class="xref py py-obj docutils literal"><span class="pre">ValidationError</span></code>
will be raised.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>samples</strong> : (n, d) array_like</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">n</span></code> and <code class="docutils literal"><span class="pre">d</span></code> must match what is eventually passed to <a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.PDF">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">PDF</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#PDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF" title="Permalink to this definition">¶</a></dt>
<dd><p>An arbitrary distribution from a PDF.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : vector_like (n,)</p>
<blockquote>
<div><p>Values of the points to sample from (interpolated).</p>
</div></blockquote>
<p><strong>p</strong> : vector_like (n,)</p>
<blockquote class="last">
<div><p>Probabilities of the <code class="xref py py-obj docutils literal"><span class="pre">x</span></code> points.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.SqrtBeta">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">SqrtBeta</code><span class="sig-paren">(</span><em>n</em>, <em>m=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the square root of a Beta distributed random variable.</p>
<p>Given <code class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></code> dimensional random unit vectors, the length of subvectors
with <code class="docutils literal"><span class="pre">m</span></code> elements will be distributed according to this distribution.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>n: int</strong></p>
<blockquote>
<div><p>Number of subvectors.</p>
</div></blockquote>
<p><strong>m: int, optional (Default: 1)</strong></p>
<blockquote class="last">
<div><p>Length of each subvector.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SubvectorLength</span></code></a></p>
</div>
<dl class="method">
<dt id="nengo.dists.SqrtBeta.cdf">
<code class="descname">cdf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.cdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Evaluation points in [0, 1].</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>cdf</strong> : array_like</p>
<blockquote class="last">
<div><p>Probability that <code class="xref py py-obj docutils literal"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Evaluation points in [0, 1].</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>pdf</strong> : array_like</p>
<blockquote class="last">
<div><p>Probability density at <code class="docutils literal"><span class="pre">x</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.ppf">
<code class="descname">ppf</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.ppf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>y</strong> : array_like</p>
<blockquote>
<div><p>Cumulative probabilities in [0, 1].</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>ppf</strong> : array_like</p>
<blockquote class="last">
<div><p>Evaluation points <code class="docutils literal"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.SubvectorLength">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">SubvectorLength</code><span class="sig-paren">(</span><em>dimensions</em>, <em>subdimensions=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SubvectorLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SubvectorLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the length of a subvectors of a unit vector.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dimensions</strong> : int</p>
<blockquote>
<div><p>Dimensionality of the complete unit vector.</p>
</div></blockquote>
<p><strong>subdimensions</strong> : int, optional (Default: 1)</p>
<blockquote class="last">
<div><p>Dimensionality of the subvector.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.CosineSimilarity">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">CosineSimilarity</code><span class="sig-paren">(</span><em>dimensions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the cosine of the angle between two random vectors.</p>
<p>The “cosine similarity” is the cosine of the angle between two vectors,
which is equal to the dot product of the vectors, divided by the L2-norms
of the individual vectors. When these vectors are unit length, this is then
simply the distribution of their dot product.</p>
<p>This is also equivalent to the distribution of a single coefficient from a
unit vector (a single dimension of <code class="docutils literal"><span class="pre">UniformHypersphere(surface=True)</span></code>).
Furthermore, <code class="docutils literal"><span class="pre">CosineSimilarity(d+2)</span></code> is equivalent to the distribution of
a single coordinate from points uniformly sampled from the d-dimensional
unit ball (a single dimension of
<code class="docutils literal"><span class="pre">UniformHypersphere(surface=False).sample(n,</span> <span class="pre">d)</span></code>). These relationships
have been detailed in <a class="reference internal" href="#voelker201723" id="id1">[Voelker201723]</a>.</p>
<p>This can be used to calculate an intercept <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> such that
<code class="docutils literal"><span class="pre">dot(u,</span> <span class="pre">v)</span> <span class="pre">&gt;=</span> <span class="pre">c</span></code> with probability <code class="docutils literal"><span class="pre">p</span></code>, for random unit vectors <code class="docutils literal"><span class="pre">u</span></code>
and <code class="docutils literal"><span class="pre">v</span></code>. In other words, a neuron with intercept <code class="docutils literal"><span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> will
fire with probability <code class="docutils literal"><span class="pre">p</span></code> for a random unit length input.</p>
<table class="docutils citation" frame="void" id="voelker201723" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Voelker201723]</a></td><td><a class="reference external" href="http://compneuro.uwaterloo.ca/publications/voelker2017.html">Aaron R. Voelker, Jan Gosmann, and Terrence C. Stewart.
Efficiently sampling vectors and coordinates from the n-sphere and
n-ball. Technical Report, Centre for Theoretical Neuroscience,
Waterloo, ON, 2017</a>,
<a class="reference external" href="https://dx.doi.org/10.13140/RG.2.2.15829.01767/1">doi:10.13140/RG.2.2.15829.01767/1</a>.</td></tr>
</tbody>
</table>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dimensions: int</strong></p>
<blockquote class="last">
<div><p>Dimensionality of the complete unit vector.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="neuron-types">
<h2>Neuron types<a class="headerlink" href="#neuron-types" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">nengo.neurons.NeuronType</span></code></a></td>
<td>Base class for Nengo neuron models.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Direct</span></code></a></td>
<td>Signifies that an ensemble should simulate in direct mode.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.RectifiedLinear" title="nengo.RectifiedLinear"><code class="xref py py-obj docutils literal"><span class="pre">nengo.RectifiedLinear</span></code></a></td>
<td>A rectified linear neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Sigmoid" title="nengo.Sigmoid"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Sigmoid</span></code></a></td>
<td>A neuron model whose response curve is a sigmoid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.LIF" title="nengo.LIF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LIF</span></code></a></td>
<td>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.LIFRate" title="nengo.LIFRate"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LIFRate</span></code></a></td>
<td>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.AdaptiveLIF" title="nengo.AdaptiveLIF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.AdaptiveLIF</span></code></a></td>
<td>Adaptive spiking version of the LIF neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.AdaptiveLIFRate" title="nengo.AdaptiveLIFRate"><code class="xref py py-obj docutils literal"><span class="pre">nengo.AdaptiveLIFRate</span></code></a></td>
<td>Adaptive non-spiking version of the LIF neuron model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Izhikevich" title="nengo.Izhikevich"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Izhikevich</span></code></a></td>
<td>Izhikevich neuron model.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.neurons.NeuronType">
<em class="property">class </em><code class="descclassname">nengo.neurons.</code><code class="descname">NeuronType</code><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for Nengo neuron models.</p>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>probeable</strong></td>
<td>(tuple) Signals that can be probed in the neuron population.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.neurons.NeuronType.current">
<code class="descname">current</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute current injected in each neuron given input, gain and bias.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Vector-space input.</p>
</div></blockquote>
<p><strong>gain</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Gains associated with each neuron.</p>
</div></blockquote>
<p><strong>bias</strong> : (n_neurons,) array_like</p>
<blockquote class="last">
<div><p>Bias current associated with each neuron.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gain and bias needed to satisfy max_rates, intercepts.</p>
<p>This takes the neurons, approximates their response function, and then
uses that approximation to find the gain and bias value that will give
the requested intercepts and max_rates.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>max_rates</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Maximum firing rates of neurons.</p>
</div></blockquote>
<p><strong>intercepts</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>X-intercepts of neurons.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>gain</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</div></blockquote>
<p><strong>bias</strong> : (n_neurons,) array_like</p>
<blockquote class="last">
<div><p>Bias current associated with each neuron.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max_rates and intercepts given gain and bias.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>gain</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</div></blockquote>
<p><strong>bias</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Bias current associated with each neuron.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>max_rates</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Maximum firing rates of neurons.</p>
</div></blockquote>
<p><strong>intercepts</strong> : (n_neurons,) array_like</p>
<blockquote class="last">
<div><p>X-intercepts of neurons.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given vector input, <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>This default implementation takes the naive approach of running the
step function for a second. This should suffice for most rate-based
neuron types; for spiking neurons it will likely fail (those models
should override this function).</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Vector-space input.</p>
</div></blockquote>
<p><strong>gain</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Gains associated with each neuron.</p>
</div></blockquote>
<p><strong>bias</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Bias current associated with each neuron.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>rates</strong> : (n_neurons,) ndarray</p>
<blockquote class="last">
<div><p>The firing rates at each given value of <code class="xref py py-obj docutils literal"><span class="pre">x</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dt</strong> : float</p>
<blockquote>
<div><p>Simulation timestep.</p>
</div></blockquote>
<p><strong>J</strong> : (n_neurons,) array_like</p>
<blockquote>
<div><p>Input currents associated with each neuron.</p>
</div></blockquote>
<p><strong>output</strong> : (n_neurons,) array_like</p>
<blockquote class="last">
<div><p>Output activities associated with each neuron.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Direct">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Direct</code><a class="reference internal" href="_modules/nengo/neurons.html#Direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Signifies that an ensemble should simulate in direct mode.</p>
<p>In direct mode, the ensemble represents and transforms signals perfectly,
rather than through a neural approximation. Note that direct mode ensembles
with recurrent connections can easily diverge; most other neuron types will
instead saturate at a certain high firing rate.</p>
<dl class="method">
<dt id="nengo.Direct.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if called.</p>
<p>Rather than calling this function, the simulator will detect that
the ensemble is in direct mode, and bypass the neural approximation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.RectifiedLinear">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">RectifiedLinear</code><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified linear neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless it passes below zero, at which point
the neural activity will stay at zero.</p>
<dl class="method">
<dt id="nengo.RectifiedLinear.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine gain and bias by shifting and scaling the lines.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the rectification nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Sigmoid">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Sigmoid</code><span class="sig-paren">(</span><em>tau_ref=0.0025</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>A neuron model whose response curve is a sigmoid.</p>
<p>Since the tuning curves are strictly positive, the <code class="docutils literal"><span class="pre">intercepts</span></code>
correspond to the inflection point of each sigmoid. That is,
<code class="docutils literal"><span class="pre">f(intercept)</span> <span class="pre">=</span> <span class="pre">0.5</span></code> where <code class="docutils literal"><span class="pre">f</span></code> is the pure sigmoid function.</p>
<dl class="method">
<dt id="nengo.Sigmoid.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the sigmoid nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.LIF">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LIF</code><span class="sig-paren">(</span><em>tau_rc=0.02</em>, <em>tau_ref=0.002</em>, <em>min_voltage=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau_rc</strong> : float</p>
<blockquote>
<div><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</div></blockquote>
<p><strong>tau_ref</strong> : float</p>
<blockquote>
<div><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</div></blockquote>
<p><strong>min_voltage</strong> : float</p>
<blockquote class="last">
<div><p>Minimum value for the membrane voltage. If <code class="docutils literal"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.LIFRate">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LIFRate</code><span class="sig-paren">(</span><em>tau_rc=0.02</em>, <em>tau_ref=0.002</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau_rc</strong> : float</p>
<blockquote>
<div><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</div></blockquote>
<p><strong>tau_ref</strong> : float</p>
<blockquote class="last">
<div><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</div></blockquote>
</dd>
</dl>
<dl class="method">
<dt id="nengo.LIFRate.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always use LIFRate to determine rates.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIF">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">AdaptiveLIF</code><span class="sig-paren">(</span><em>tau_n=1</em>, <em>inc_n=0.01</em>, <em>**lif_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is incremented by <code class="docutils literal"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau_n</strong> : float</p>
<blockquote>
<div><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</div></blockquote>
<p><strong>inc_n</strong> : float</p>
<blockquote>
<div><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</div></blockquote>
<p><strong>tau_rc</strong> : float</p>
<blockquote>
<div><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</div></blockquote>
<p><strong>tau_ref</strong> : float</p>
<blockquote class="last">
<div><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1111" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R1111]</a></td><td>Koch, Christof. Biophysics of Computation: Information Processing
in Single Neurons. Oxford University Press, 1999. p. 339</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.AdaptiveLIF.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em>, <em>voltage</em>, <em>ref</em>, <em>adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIF nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIFRate">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">AdaptiveLIFRate</code><span class="sig-paren">(</span><em>tau_n=1</em>, <em>inc_n=0.01</em>, <em>**lif_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive non-spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is incremented by <code class="docutils literal"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau_n</strong> : float</p>
<blockquote>
<div><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</div></blockquote>
<p><strong>inc_n</strong> : float</p>
<blockquote>
<div><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</div></blockquote>
<p><strong>tau_rc</strong> : float</p>
<blockquote>
<div><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</div></blockquote>
<p><strong>tau_ref</strong> : float</p>
<blockquote class="last">
<div><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1313" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R1313]</a></td><td>Koch, Christof. Biophysics of Computation: Information Processing
in Single Neurons. Oxford University Press, 1999. p. 339</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.AdaptiveLIFRate.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em>, <em>adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Izhikevich">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Izhikevich</code><span class="sig-paren">(</span><em>tau_recovery=0.02</em>, <em>coupling=0.2</em>, <em>reset_voltage=-65.0</em>, <em>reset_recovery=8.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich" title="Permalink to this definition">¶</a></dt>
<dd><p>Izhikevich neuron model.</p>
<p>This implementation is based on the original paper <a class="reference internal" href="#r1515" id="id4">[R1515]</a>;
however, we rename some variables for clarity.
What was originally ‘v’ we term ‘voltage’, which represents the membrane
potential of each neuron. What was originally ‘u’ we term ‘recovery’,
which represents membrane recovery, “which accounts for the activation
of K+ ionic currents and inactivation of Na+ ionic currents.”
The ‘a’, ‘b’, ‘c’, and ‘d’ parameters are also renamed
(see the parameters below).</p>
<p>We use default values that correspond to regular spiking (‘RS’) neurons.
For other classes of neurons, set the parameters as follows.</p>
<ul class="simple">
<li>Intrinsically bursting (IB): <code class="docutils literal"><span class="pre">reset_voltage=-55,</span> <span class="pre">reset_recovery=4</span></code></li>
<li>Chattering (CH): <code class="docutils literal"><span class="pre">reset_voltage=-50,</span> <span class="pre">reset_recovery=2</span></code></li>
<li>Fast spiking (FS): <code class="docutils literal"><span class="pre">tau_recovery=0.1</span></code></li>
<li>Low-threshold spiking (LTS): <code class="docutils literal"><span class="pre">coupling=0.25</span></code></li>
<li>Resonator (RZ): <code class="docutils literal"><span class="pre">tau_recovery=0.1,</span> <span class="pre">coupling=0.26</span></code></li>
</ul>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau_recovery</strong> : float, optional (Default: 0.02)</p>
<blockquote>
<div><p>(Originally ‘a’) Time scale of the recovery varaible.</p>
</div></blockquote>
<p><strong>coupling</strong> : float, optional (Default: 0.2)</p>
<blockquote>
<div><p>(Originally ‘b’) How sensitive recovery is to subthreshold
fluctuations of voltage.</p>
</div></blockquote>
<p><strong>reset_voltage</strong> : float, optional (Default: -65.)</p>
<blockquote>
<div><p>(Originally ‘c’) The voltage to reset to after a spike, in millivolts.</p>
</div></blockquote>
<p><strong>reset_recovery</strong> : float, optional (Default: 8.)</p>
<blockquote class="last">
<div><p>(Originally ‘d’) The recovery value to reset to after a spike.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1515" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1515]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> E. M. Izhikevich, “Simple model of spiking neurons.”
IEEE Transactions on Neural Networks, vol. 14, no. 6, pp. 1569-1572.
(<a class="reference external" href="http://www.izhikevich.org/publications/spikes.pdf">http://www.izhikevich.org/publications/spikes.pdf</a>)</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Izhikevich.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates steady-state firing rate given gain and bias.</p>
<p>Uses the <code class="xref py py-obj docutils literal"><span class="pre">settled_firingrate</span></code> helper function.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Izhikevich.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>spiked</em>, <em>voltage</em>, <em>recovery</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the Izhikevich nonlinearity.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="learning-rule-types">
<h2>Learning rule types<a class="headerlink" href="#learning-rule-types" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.learning_rules.LearningRuleType" title="nengo.learning_rules.LearningRuleType"><code class="xref py py-obj docutils literal"><span class="pre">nengo.learning_rules.LearningRuleType</span></code></a></td>
<td>Base class for all learning rule objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal"><span class="pre">nengo.PES</span></code></a></td>
<td>Prescribed Error Sensitivity learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.BCM" title="nengo.BCM"><code class="xref py py-obj docutils literal"><span class="pre">nengo.BCM</span></code></a></td>
<td>Bienenstock-Cooper-Munroe learning rule.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Oja" title="nengo.Oja"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Oja</span></code></a></td>
<td>Oja learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Voja" title="nengo.Voja"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Voja</span></code></a></td>
<td>Vector Oja learning rule.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.learning_rules.LearningRuleType">
<em class="property">class </em><code class="descclassname">nengo.learning_rules.</code><code class="descname">LearningRuleType</code><span class="sig-paren">(</span><em>learning_rate=1e-06</em>, <em>size_in=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#LearningRuleType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all learning rule objects.</p>
<p>To use a learning rule, pass it as a <code class="docutils literal"><span class="pre">learning_rule_type</span></code> keyword
argument to the <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> on which you want to do learning.</p>
<p>Each learning rule exposes two important pieces of metadata that the
builder uses to determine what information should be stored.</p>
<p>The <code class="docutils literal"><span class="pre">size_in</span></code> is the dimensionality of the incoming error signal. It
can either take an integer or one of the following string values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'pre'</span></code>: vector error signal in pre-object space</li>
<li><code class="docutils literal"><span class="pre">'post'</span></code>: vector error signal in post-object space</li>
<li><code class="docutils literal"><span class="pre">'mid'</span></code>: vector error signal in the <code class="docutils literal"><span class="pre">conn.size_mid</span></code> space</li>
<li><code class="docutils literal"><span class="pre">'pre_state'</span></code>: vector error signal in pre-synaptic ensemble space</li>
<li><code class="docutils literal"><span class="pre">'post_state'</span></code>: vector error signal in pre-synaptic ensemble space</li>
</ul>
<p>The difference between <code class="docutils literal"><span class="pre">'post_state'</span></code> and <code class="docutils literal"><span class="pre">'post'</span></code> is that with the
former, if a <code class="docutils literal"><span class="pre">Neurons</span></code> object is passed, it will use the dimensionality
of the corresponding <code class="docutils literal"><span class="pre">Ensemble</span></code>, whereas the latter simply uses the
<code class="docutils literal"><span class="pre">post</span></code> object <code class="docutils literal"><span class="pre">size_in</span></code>. Similarly with <code class="docutils literal"><span class="pre">'pre_state'</span></code> and <code class="docutils literal"><span class="pre">'pre'</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">modifies</span></code> attribute denotes the signal targeted by the rule.
Options are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'encoders'</span></code></li>
<li><code class="docutils literal"><span class="pre">'decoders'</span></code></li>
<li><code class="docutils literal"><span class="pre">'weights'</span></code></li>
</ul>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>learning_rate</strong> : float, optional (Default: 1e-6)</p>
<blockquote>
<div><p>A scalar indicating the rate at which <code class="docutils literal"><span class="pre">modifies</span></code> will be adjusted.</p>
</div></blockquote>
<p><strong>size_in</strong> : int, str, optional (Default: 0)</p>
<blockquote class="last">
<div><p>Dimensionality of the error signal (see above).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>learning_rate</strong></td>
<td>(float) A scalar indicating the rate at which <code class="docutils literal"><span class="pre">modifies</span></code> will be adjusted.</td>
</tr>
<tr class="row-odd"><td><strong>size_in</strong></td>
<td>(int, str) Dimensionality of the error signal.</td>
</tr>
<tr class="row-even"><td><strong>modifies</strong></td>
<td>(str) The signal targeted by the learning rule.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.PES">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">PES</code><span class="sig-paren">(</span><em>learning_rate=0.0001</em>, <em>pre_tau=0.005</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#PES"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PES" title="Permalink to this definition">¶</a></dt>
<dd><p>Prescribed Error Sensitivity learning rule.</p>
<p>Modifies a connection’s decoders to minimize an error signal provided
through a connection to the connection’s learning rule.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>learning_rate</strong> : float, optional (Default: 1e-4)</p>
<blockquote>
<div><p>A scalar indicating the rate at which weights will be adjusted.</p>
</div></blockquote>
<p><strong>pre_tau</strong> : float, optional (Default: 0.005)</p>
<blockquote class="last">
<div><p>Filter constant on activities of neurons in pre population.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>learning_rate</strong></td>
<td>(float) A scalar indicating the rate at which weights will be adjusted.</td>
</tr>
<tr class="row-even"><td><strong>pre_tau</strong></td>
<td>(float) Filter constant on activities of neurons in pre population.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.BCM">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">BCM</code><span class="sig-paren">(</span><em>pre_tau=0.005</em>, <em>post_tau=None</em>, <em>theta_tau=1.0</em>, <em>learning_rate=1e-09</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#BCM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.BCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bienenstock-Cooper-Munroe learning rule.</p>
<p>Modifies connection weights as a function of the presynaptic activity
and the difference between the postsynaptic activity and the average
postsynaptic activity.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>theta_tau</strong> : float, optional (Default: 1.0)</p>
<blockquote>
<div><p>A scalar indicating the time constant for theta integration.</p>
</div></blockquote>
<p><strong>pre_tau</strong> : float, optional (Default: 0.005)</p>
<blockquote>
<div><p>Filter constant on activities of neurons in pre population.</p>
</div></blockquote>
<p><strong>post_tau</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Filter constant on activities of neurons in post population.
If None, post_tau will be the same as pre_tau.</p>
</div></blockquote>
<p><strong>learning_rate</strong> : float, optional (Default: 1e-9)</p>
<blockquote class="last">
<div><p>A scalar indicating the rate at which weights will be adjusted.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The BCM rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the BCM rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the BCM rule by <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>learning_rate</strong></td>
<td>(float) A scalar indicating the rate at which weights will be adjusted.</td>
</tr>
<tr class="row-even"><td><strong>post_tau</strong></td>
<td>(float) Filter constant on activities of neurons in post population.</td>
</tr>
<tr class="row-odd"><td><strong>pre_tau</strong></td>
<td>(float) Filter constant on activities of neurons in pre population.</td>
</tr>
<tr class="row-even"><td><strong>theta_tau</strong></td>
<td>(float) A scalar indicating the time constant for theta integration.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Oja">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Oja</code><span class="sig-paren">(</span><em>pre_tau=0.005</em>, <em>post_tau=None</em>, <em>beta=1.0</em>, <em>learning_rate=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Oja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Oja" title="Permalink to this definition">¶</a></dt>
<dd><p>Oja learning rule.</p>
<p>Modifies connection weights according to the Hebbian Oja rule, which
augments typicaly Hebbian coactivity with a “forgetting” term that is
proportional to the weight of the connection and the square of the
postsynaptic activity.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>pre_tau</strong> : float, optional (Default: 0.005)</p>
<blockquote>
<div><p>Filter constant on activities of neurons in pre population.</p>
</div></blockquote>
<p><strong>post_tau</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Filter constant on activities of neurons in post population.
If None, post_tau will be the same as pre_tau.</p>
</div></blockquote>
<p><strong>beta</strong> : float, optional (Default: 1.0)</p>
<blockquote>
<div><p>A scalar weight on the forgetting term.</p>
</div></blockquote>
<p><strong>learning_rate</strong> : float, optional (Default: 1e-6)</p>
<blockquote class="last">
<div><p>A scalar indicating the rate at which weights will be adjusted.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Oja rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the Oja rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the Oja rule by <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>beta</strong></td>
<td>(float) A scalar weight on the forgetting term.</td>
</tr>
<tr class="row-even"><td><strong>learning_rate</strong></td>
<td>(float) A scalar indicating the rate at which weights will be adjusted.</td>
</tr>
<tr class="row-odd"><td><strong>post_tau</strong></td>
<td>(float) Filter constant on activities of neurons in post population.</td>
</tr>
<tr class="row-even"><td><strong>pre_tau</strong></td>
<td>(float) Filter constant on activities of neurons in pre population.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Voja">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Voja</code><span class="sig-paren">(</span><em>post_tau=0.005</em>, <em>learning_rate=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Voja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Voja" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector Oja learning rule.</p>
<p>Modifies an ensemble’s encoders to be selective to its inputs.</p>
<p>A connection to the learning rule will provide a scalar weight for the
learning rate, minus 1. For instance, 0 is normal learning, -1 is no
learning, and less than -1 causes anti-learning or “forgetting”.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>post_tau</strong> : float, optional (Default: 0.005)</p>
<blockquote>
<div><p>Filter constant on activities of neurons in post population.</p>
</div></blockquote>
<p><strong>learning_rate</strong> : float, optional (Default: 1e-2)</p>
<blockquote class="last">
<div><p>A scalar indicating the rate at which encoders will be adjusted.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>learning_rate</strong></td>
<td>(float) A scalar indicating the rate at which encoders will be adjusted.</td>
</tr>
<tr class="row-even"><td><strong>post_tau</strong></td>
<td>(float) Filter constant on activities of neurons in post population.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="processes">
<h2>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Process</span></code></a></td>
<td>A general system with input, output, and state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.PresentInput" title="nengo.processes.PresentInput"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.PresentInput</span></code></a></td>
<td>Present a series of inputs, each for the same fixed length of time.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.FilteredNoise" title="nengo.processes.FilteredNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.FilteredNoise</span></code></a></td>
<td>Filtered white noise process.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.BrownNoise" title="nengo.processes.BrownNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.BrownNoise</span></code></a></td>
<td>Brown noise process (aka Brownian noise, red noise, Wiener process).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.WhiteNoise" title="nengo.processes.WhiteNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.WhiteNoise</span></code></a></td>
<td>Full-spectrum white noise process.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.WhiteSignal" title="nengo.processes.WhiteSignal"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.WhiteSignal</span></code></a></td>
<td>An ideal low-pass filtered white noise process.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.Piecewise" title="nengo.processes.Piecewise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.Piecewise</span></code></a></td>
<td>A piecewise function with different options for interpolation.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Process">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Process</code><span class="sig-paren">(</span><em>default_size_in=0</em>, <em>default_size_out=1</em>, <em>default_dt=0.001</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>A general system with input, output, and state.</p>
<p>For more details on how to use processes and make
custom process subclasses, see <a class="reference internal" href="examples/processes.html"><span class="doc">Processes and how to use them</span></a>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>default_size_in</strong> : int (Default: 0)</p>
<blockquote>
<div><p>Sets the default size in for nodes using this process.</p>
</div></blockquote>
<p><strong>default_size_out</strong> : int (Default: 1)</p>
<blockquote>
<div><p>Sets the default size out for nodes running this process. Also,
if <code class="docutils literal"><span class="pre">d</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</div></blockquote>
<p><strong>default_dt</strong> : float (Default: 0.001 (1 millisecond))</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal"><span class="pre">trange</span></code></a>, this will be used.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures random factors will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>default_dt</strong></td>
<td>(float) If <code class="docutils literal"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>, <a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal"><span class="pre">trange</span></code></a>, this will be used.</td>
</tr>
<tr class="row-odd"><td><strong>default_size_in</strong></td>
<td>(int) The default size in for nodes using this process.</td>
</tr>
<tr class="row-even"><td><strong>default_size_out</strong></td>
<td>(int) The default size out for nodes running this process. Also, if <code class="docutils literal"><span class="pre">d</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>, this will be used.</td>
</tr>
<tr class="row-odd"><td><strong>seed</strong></td>
<td>(int or None) Random number seed. Ensures random factors will be the same each run.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Process.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>x</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from '/home/travis/miniconda/envs/test/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em>copy=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process on a given input.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<blockquote>
<div><p>The input signal given to the process.</p>
</div></blockquote>
<p><strong>d</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</p>
<blockquote>
<div><p>Random number generator used for stochstic processes.</p>
</div></blockquote>
<p><strong>copy</strong> : bool, optional (Default: True)</p>
<blockquote class="last">
<div><p>If True, a new output array will be created for output.
If False, the input signal <code class="docutils literal"><span class="pre">x</span></code> will be overwritten.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.get_rng">
<code class="descname">get_rng</code><span class="sig-paren">(</span><em>rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.get_rng"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.get_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a properly seeded independent RNG for the process step.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></p>
<blockquote class="last">
<div><p>The parent random number generator to use if the seed is not set.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>shape_in</strong> : tuple</p>
<blockquote>
<div><p>The shape of the input signal.</p>
</div></blockquote>
<p><strong>shape_out</strong> : tuple</p>
<blockquote>
<div><p>The shape of the output signal.</p>
</div></blockquote>
<p><strong>dt</strong> : float</p>
<blockquote>
<div><p>The simulation timestep.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></p>
<blockquote class="last">
<div><p>A random number generator.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>t</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from '/home/travis/miniconda/envs/test/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given length of time.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>t</strong> : float</p>
<blockquote>
<div><p>The length of time to run.</p>
</div></blockquote>
<p><strong>d</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</p>
<blockquote class="last">
<div><p>Random number generator used for stochstic processes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run_steps">
<code class="descname">run_steps</code><span class="sig-paren">(</span><em>n_steps</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from '/home/travis/miniconda/envs/test/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given number of steps.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>n_steps</strong> : int</p>
<blockquote>
<div><p>The number of steps to run.</p>
</div></blockquote>
<p><strong>d</strong> : int, optional (Default: None)</p>
<blockquote>
<div><p>Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</p>
<blockquote class="last">
<div><p>Random number generator used for stochstic processes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.ntrange">
<code class="descname">ntrange</code><span class="sig-paren">(</span><em>n_steps</em>, <em>dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.ntrange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.ntrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given number of steps.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>n_steps</strong> : int</p>
<blockquote>
<div><p>The given number of steps.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote class="last">
<div><p>Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.trange">
<code class="descname">trange</code><span class="sig-paren">(</span><em>t</em>, <em>dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.trange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.trange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given length of time.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>t</strong> : float</p>
<blockquote>
<div><p>The given length of time.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote class="last">
<div><p>Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.PresentInput">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">PresentInput</code><span class="sig-paren">(</span><em>inputs</em>, <em>presentation_time</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#PresentInput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput" title="Permalink to this definition">¶</a></dt>
<dd><p>Present a series of inputs, each for the same fixed length of time.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>inputs</strong> : array_like</p>
<blockquote>
<div><p>Inputs to present, where each row is an input. Rows will be flattened.</p>
</div></blockquote>
<p><strong>presentation_time</strong> : float</p>
<blockquote class="last">
<div><p>Show each input for this amount of time (in seconds).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.FilteredNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">FilteredNoise</code><span class="sig-paren">(</span><em>synapse=Lowpass(0.005)</em>, <em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>scale=True</em>, <em>synapse_kwargs=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#FilteredNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Filtered white noise process.</p>
<p>This process takes white noise and filters it using the provided synapse.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>synapse</strong> : Synapse, optional (Default: <code class="docutils literal"><span class="pre">Lowpass(tau=0.005)</span></code>)</p>
<blockquote>
<div><p>The synapse to use to filter the noise.</p>
</div></blockquote>
<p><strong>dist</strong> : Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</p>
<blockquote>
<div><p>The distribution used to generate the white noise.</p>
</div></blockquote>
<p><strong>scale</strong> : bool, optional (Default: True)</p>
<blockquote>
<div><p>Whether to scale the white noise for integration, making the output
signal invariant to <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</div></blockquote>
<p><strong>synapse_kwargs</strong> : dict, optional (Default: None)</p>
<blockquote>
<div><p>Arguments to pass to <code class="docutils literal"><span class="pre">synapse.make_step</span></code>.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures noise will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.BrownNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">BrownNoise</code><span class="sig-paren">(</span><em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#BrownNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.BrownNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p>
<p>This process is the integral of white noise.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dist</strong> : Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</p>
<blockquote>
<div><p>The distribution used to generate the white noise.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures noise will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">WhiteNoise</code><span class="sig-paren">(</span><em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>scale=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Full-spectrum white noise process.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>dist</strong> : Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</p>
<blockquote>
<div><p>The distribution from which to draw samples.</p>
</div></blockquote>
<p><strong>scale</strong> : bool, optional (Default: True)</p>
<blockquote>
<div><p>Whether to scale the white noise for integration. Integrating white
noise requires using a time constant of <code class="docutils literal"><span class="pre">sqrt(dt)</span></code> instead of <code class="docutils literal"><span class="pre">dt</span></code>
on the noise term <a class="reference internal" href="#r1919" id="id6">[R1919]</a>, to ensure the magnitude of the integrated
noise does not change with <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures noise will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1919" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1919]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Gillespie, D.T. (1996) Exact numerical simulation of the Ornstein-
Uhlenbeck process and its integral. Phys. Rev. E 54, pp. 2084-91.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteSignal">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">WhiteSignal</code><span class="sig-paren">(</span><em>period</em>, <em>high</em>, <em>rms=0.5</em>, <em>y0=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteSignal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>An ideal low-pass filtered white noise process.</p>
<p>This signal is created in the frequency domain, and designed to have
exactly equal power at all frequencies below the cut-off frequency,
and no power above the cut-off.</p>
<p>The signal is naturally periodic, so it can be used beyond its period
while still being continuous with continuous derivatives.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>period</strong> : float</p>
<blockquote>
<div><p>A white noise signal with this period will be generated.
Samples will repeat after this duration.</p>
</div></blockquote>
<p><strong>high</strong> : float</p>
<blockquote>
<div><p>The cut-off frequency of the low-pass filter, in Hz.
Must not exceed the Nyquist frequency for the simulation
timestep, which is <code class="docutils literal"><span class="pre">0.5</span> <span class="pre">/</span> <span class="pre">dt</span></code>.</p>
</div></blockquote>
<p><strong>rms</strong> : float, optional (Default: 0.5)</p>
<blockquote>
<div><p>The root mean square power of the filtered signal</p>
</div></blockquote>
<p><strong>y0</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>Align the phase of each output dimension to begin at the value
that is closest (in absolute value) to y0.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures noise will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.Piecewise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">Piecewise</code><span class="sig-paren">(</span><em>data</em>, <em>interpolation='zero'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#Piecewise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>A piecewise function with different options for interpolation.</p>
<p>Given an input dictionary of <code class="docutils literal"><span class="pre">{0:</span> <span class="pre">0,</span> <span class="pre">0.5:</span> <span class="pre">-1,</span> <span class="pre">0.75:</span> <span class="pre">0.5,</span> <span class="pre">1:</span> <span class="pre">0}</span></code>,
this process  will emit the numerical values (0, -1, 0.5, 0)
starting at the corresponding time points (0, 0.5, 0.75, 1).</p>
<p>The keys in the input dictionary must be times (float or int).
The values in the dictionary can be floats, lists of floats,
or numpy arrays. All lists or numpy arrays must be of the same length,
as the output shape of the process will be determined by the shape
of the values.</p>
<p>Interpolation on the data points using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v0.19.1)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a> is also
supported. The default interpolation is ‘zero’, which creates a
piecewise function whose values change at the specified time points.
So the above example would be shortcut for:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.75</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For times before the first specified time, an array of zeros (of
the correct length) will be emitted.
This means that the above can be simplified to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>data</strong> : dict</p>
<blockquote>
<div><p>A dictionary mapping times to the values that should be emitted
at those times. Times must be numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</div></blockquote>
<p><strong>interpolation</strong> : str, optional (Default: ‘zero’)</p>
<blockquote class="last">
<div><p>One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values begin at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v0.19.1)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nengo.processes</span> <span class="k">import</span> <span class="n">Piecewise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">process</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">u</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">size_out</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">default_size_out</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">up</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">up</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="go">array([[ 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.58</span><span class="p">]</span>
<span class="go">array([[ 1.]])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>data</strong></td>
<td>(dict) A dictionary mapping times to the values that should be emitted at those times. Times are numbers (ints or floats), while values can be numbers, lists of numbers, numpy arrays of numbers, or callables that return any of those options.</td>
</tr>
<tr class="row-odd"><td><strong>interpolation</strong></td>
<td>(str) One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’. Specifies how to interpolate between times with specified value. ‘zero’ creates a plain piecewise function whose values change at corresponding time points, while all other options interpolate as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v0.19.1)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="synapse-models">
<h2>Synapse models<a class="headerlink" href="#synapse-models" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.Synapse</span></code></a></td>
<td>Abstract base class for synapse models.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.synapses.filt" title="nengo.synapses.filt"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.filt</span></code></a></td>
<td>Filter <code class="docutils literal"><span class="pre">signal</span></code> with <code class="docutils literal"><span class="pre">synapse</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.synapses.filtfilt" title="nengo.synapses.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.filtfilt</span></code></a></td>
<td>Zero-phase filtering of <code class="docutils literal"><span class="pre">signal</span></code> using the <code class="docutils literal"><span class="pre">synapse</span></code> filter.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.LinearFilter" title="nengo.LinearFilter"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LinearFilter</span></code></a></td>
<td>General linear time-invariant (LTI) system synapse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Lowpass" title="nengo.Lowpass"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Lowpass</span></code></a></td>
<td>Standard first-order lowpass filter synapse.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Alpha" title="nengo.Alpha"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Alpha</span></code></a></td>
<td>Alpha-function filter synapse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.synapses.Triangle" title="nengo.synapses.Triangle"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.Triangle</span></code></a></td>
<td>Triangular finite impulse response (FIR) synapse.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.synapses.Synapse">
<em class="property">class </em><code class="descclassname">nengo.synapses.</code><code class="descname">Synapse</code><span class="sig-paren">(</span><em>default_size_in=1</em>, <em>default_size_out=None</em>, <em>default_dt=0.001</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for synapse models.</p>
<p>Conceptually, a synapse model emulates a biological synapse, taking in
input in the form of released neurotransmitter and opening ion channels
to allow more or less current to flow into the neuron.</p>
<p>In Nengo, the implementation of a synapse is as a specific case of a
<a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal"><span class="pre">Process</span></code></a> in which the input and output shapes are the same.
The input is the current across the synapse, and the output is the current
that will be induced in the postsynaptic neuron.</p>
<p>Synapses also contain the <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filt</span></code></a> and <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filtfilt</span></code></a> methods,
which make it easy to use Nengo’s synapse models outside of Nengo
simulations.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>default_size_in</strong> : int, optional (Default: 1)</p>
<blockquote>
<div><p>The size_in used if not specified.</p>
</div></blockquote>
<p><strong>default_size_out</strong> : int (Default: None)</p>
<blockquote>
<div><p>The size_out used if not specified.
If None, will be the same as default_size_in.</p>
</div></blockquote>
<p><strong>default_dt</strong> : float (Default: 0.001 (1 millisecond))</p>
<blockquote>
<div><p>The simulation timestep used if not specified.</p>
</div></blockquote>
<p><strong>seed</strong> : int, optional (Default: None)</p>
<blockquote class="last">
<div><p>Random number seed. Ensures random factors will be the same each run.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>default_dt</strong></td>
<td>(float (Default: 0.001 (1 millisecond))) The simulation timestep used if not specified.</td>
</tr>
<tr class="row-even"><td><strong>default_size_in</strong></td>
<td>(int (Default: 0)) The size_in used if not specified.</td>
</tr>
<tr class="row-odd"><td><strong>default_size_out</strong></td>
<td>(int (Default: 1)) The size_out used if not specified.</td>
</tr>
<tr class="row-even"><td><strong>seed</strong></td>
<td>(int, optional (Default: None)) Random number seed. Ensures random factors will be the same each run.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.synapses.Synapse.filt">
<code class="descname">filt</code><span class="sig-paren">(</span><em>x</em>, <em>dt=None</em>, <em>axis=0</em>, <em>y0=None</em>, <em>copy=True</em>, <em>filtfilt=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal"><span class="pre">x</span></code> with this synapse model.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>The signal to filter.</p>
</div></blockquote>
<p><strong>dt</strong> : float, optional (Default: None)</p>
<blockquote>
<div><p>The timestep of the input signal.
If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional (Default: 0)</p>
<blockquote>
<div><p>The axis along which to filter.</p>
</div></blockquote>
<p><strong>y0</strong> : array_like, optional (Default: None)</p>
<blockquote>
<div><p>The starting state of the filter output. If None, the initial
value of the input signal along the axis filtered will be used.</p>
</div></blockquote>
<p><strong>copy</strong> : bool, optional (Default: True)</p>
<blockquote>
<div><p>Whether to copy the input data, or simply work in-place.</p>
</div></blockquote>
<p><strong>filtfilt</strong> : bool, optional (Default: False)</p>
<blockquote class="last">
<div><p>If True, runs the process forward then backward on the signal,
for zero-phase filtering (like Matlab’s <code class="docutils literal"><span class="pre">filtfilt</span></code>).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.filtfilt">
<code class="descname">filtfilt</code><span class="sig-paren">(</span><em>x</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal"><span class="pre">x</span></code> using this filter.</p>
<p>Equivalent to <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">filt(x,</span> <span class="pre">filtfilt=True,</span> <span class="pre">**kwargs)</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the synapse forward one time step.</p>
<p>At a minimum, Synapse subclasses must implement this method.
That implementation should return a callable that will perform
the synaptic filtering operation.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>shape_in</strong> : tuple</p>
<blockquote>
<div><p>Shape of the input signal to be filtered.</p>
</div></blockquote>
<p><strong>shape_out</strong> : tuple</p>
<blockquote>
<div><p>Shape of the output filtered signal.</p>
</div></blockquote>
<p><strong>dt</strong> : float</p>
<blockquote>
<div><p>The timestep of the simulation.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></p>
<blockquote>
<div><p>Random number generator.</p>
</div></blockquote>
<p><strong>y0</strong> : array_like, optional (Default: None)</p>
<blockquote>
<div><p>The starting state of the filter output. If None, each dimension
of the state will start at zero.</p>
</div></blockquote>
<p><strong>dtype</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.dtype</span></code></a> (Default: np.float64)</p>
<blockquote class="last">
<div><p>Type of data used by the synapse model. This is important for
ensuring that certain synapses avoid or force integer division.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filt">
<code class="descclassname">nengo.synapses.</code><code class="descname">filt</code><span class="sig-paren">(</span><em>signal</em>, <em>synapse</em>, <em>dt</em>, <em>axis=0</em>, <em>x0=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal"><span class="pre">signal</span></code> with <code class="docutils literal"><span class="pre">synapse</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filtfilt">
<code class="descclassname">nengo.synapses.</code><code class="descname">filtfilt</code><span class="sig-paren">(</span><em>signal</em>, <em>synapse</em>, <em>dt</em>, <em>axis=0</em>, <em>x0=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal"><span class="pre">signal</span></code> using the <code class="docutils literal"><span class="pre">synapse</span></code> filter.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filtfilt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LinearFilter</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>analog=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>General linear time-invariant (LTI) system synapse.</p>
<p>This class can be used to implement any linear filter, given the
filter’s transfer function. <a class="reference internal" href="#r2526" id="id8">[R2526]</a></p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>num</strong> : array_like</p>
<blockquote>
<div><p>Numerator coefficients of transfer function.</p>
</div></blockquote>
<p><strong>den</strong> : array_like</p>
<blockquote>
<div><p>Denominator coefficients of transfer function.</p>
</div></blockquote>
<p><strong>analog</strong> : boolean, optional (Default: True)</p>
<blockquote class="last">
<div><p>Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2526" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2526]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Filter_%28signal_processing%29">https://en.wikipedia.org/wiki/Filter_%28signal_processing%29</a></td></tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>analog</strong></td>
<td>(boolean) Whether the synapse coefficients are analog (i.e. continuous-time), or discrete. Analog coefficients will be converted to discrete for simulation using the simulator <code class="docutils literal"><span class="pre">dt</span></code>.</td>
</tr>
<tr class="row-even"><td><strong>den</strong></td>
<td>(ndarray) Denominator coefficients of transfer function.</td>
</tr>
<tr class="row-odd"><td><strong>num</strong></td>
<td>(ndarray) Numerator coefficients of transfer function.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.LinearFilter.combine">
<code class="descname">combine</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine in series with another LinearFilter.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transfer function at the given frequencies.</p>
<p class="rubric">Examples</p>
<p>Using the <code class="docutils literal"><span class="pre">evaluate</span></code> function to make a Bode plot:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">synapse</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">LinearFilter</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">synapse</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;magnitude [dB]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;phase [radians]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>method='zoh'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">Step</span></code></a> instance that implements the linear filter.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.Step">
<em class="property">class </em><code class="descname">Step</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.Step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for LTI filtering step functions.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.NoDen">
<em class="property">class </em><code class="descname">NoDen</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.NoDen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.NoDen" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for transfer functions with no denominator.</p>
<p>This step function should be much faster than the equivalent general
step function.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.Simple">
<em class="property">class </em><code class="descname">Simple</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em>, <em>y0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.Simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.Simple" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for transfer functions with one num and den.</p>
<p>This step function should be much faster than the equivalent general
step function.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.General">
<em class="property">class </em><code class="descname">General</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em>, <em>y0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.General"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.General" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for any given transfer function.</p>
<p>Implements a discrete-time LTI system using the difference equation
<a class="reference internal" href="#r262628" id="id10">[R262628]</a> for the given transfer function (num, den).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r262628" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R262628]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Digital_filter#Difference_equation">https://en.wikipedia.org/wiki/Digital_filter#Difference_equation</a></td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Lowpass">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Lowpass</code><span class="sig-paren">(</span><em>tau</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Lowpass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard first-order lowpass filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau</strong> : float</p>
<blockquote class="last">
<div><p>The time constant of the filter in seconds.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>tau</strong></td>
<td>(float) The time constant of the filter in seconds.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Lowpass.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Lowpass.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an optimized <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">LinearFilter.Step</span></code></a> subclass.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Alpha">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Alpha</code><span class="sig-paren">(</span><em>tau</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha-function filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">alpha</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<p>and was found by <a class="reference internal" href="#r3030" id="id12">[R3030]</a> to be a good basic model for synapses.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>tau</strong> : float</p>
<blockquote class="last">
<div><p>The time constant of the filter in seconds.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3030" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R3030]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> Mainen, Z.F. and Sejnowski, T.J. (1995). Reliability of spike timing
in neocortical neurons. Science (New York, NY), 268(5216):1503-6.</td></tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>tau</strong></td>
<td>(float) The time constant of the filter in seconds.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Alpha.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Alpha.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an optimized <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">LinearFilter.Step</span></code></a> subclass.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.synapses.Triangle">
<em class="property">class </em><code class="descclassname">nengo.synapses.</code><code class="descname">Triangle</code><span class="sig-paren">(</span><em>t</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular finite impulse response (FIR) synapse.</p>
<p>This synapse has a triangular and finite impulse response. The length of
the triangle is <code class="docutils literal"><span class="pre">t</span></code> seconds; thus the digital filter will have
<code class="docutils literal"><span class="pre">t</span> <span class="pre">/</span> <span class="pre">dt</span> <span class="pre">+</span> <span class="pre">1</span></code> taps.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>t</strong> : float</p>
<blockquote class="last">
<div><p>Length of the triangle, in seconds.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>t</strong></td>
<td>(float) Length of the triangle, in seconds.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.synapses.Triangle.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a custom step function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="decoder-and-connection-weight-solvers">
<h2>Decoder and connection weight solvers<a class="headerlink" href="#decoder-and-connection-weight-solvers" title="Permalink to this headline">¶</a></h2>
<table class="longtable table table-bordered">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Solver</span></code></a></td>
<td>Decoder or weight solver.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Lstsq</span></code></a></td>
<td>Unregularized least-squares solver.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqNoise" title="nengo.solvers.LstsqNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqNoise</span></code></a></td>
<td>Least-squares solver with additive Gaussian white noise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqMultNoise" title="nengo.solvers.LstsqMultNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqMultNoise</span></code></a></td>
<td>Least-squares solver with multiplicative white noise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL2</span></code></a></td>
<td>Least-squares solver with L2 regularization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL2nz</span></code></a></td>
<td>Least-squares solver with L2 regularization on non-zero components.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqL1" title="nengo.solvers.LstsqL1"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL1</span></code></a></td>
<td>Least-squares solver with L1 and L2 regularization (elastic net).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqDrop" title="nengo.solvers.LstsqDrop"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqDrop</span></code></a></td>
<td>Find sparser decoders/weights by dropping small values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.Nnls" title="nengo.solvers.Nnls"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Nnls</span></code></a></td>
<td>Non-negative least-squares solver without regularization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.NnlsL2" title="nengo.solvers.NnlsL2"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NnlsL2</span></code></a></td>
<td>Non-negative least-squares solver with L2 regularization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.NnlsL2nz" title="nengo.solvers.NnlsL2nz"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NnlsL2nz</span></code></a></td>
<td>Non-negative least-squares with L2 regularization on nonzero components.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.NoSolver" title="nengo.solvers.NoSolver"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NoSolver</span></code></a></td>
<td>Manually pass in weights, bypassing the decoder solver.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.solvers.Solver">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Solver</code><span class="sig-paren">(</span><em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Decoder or weight solver.</p>
<dl class="method">
<dt id="nengo.solvers.Solver.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>A</em>, <em>Y</em>, <em>rng=None</em>, <em>E=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the solver.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>A</strong> : (n_eval_points, n_neurons) array_like</p>
<blockquote>
<div><p>Matrix of the neurons’ activities at the evaluation points</p>
</div></blockquote>
<p><strong>Y</strong> : (n_eval_points, dimensions) array_like</p>
<blockquote>
<div><p>Matrix of the target decoded values for each of the D dimensions,
at each of the evaluation points.</p>
</div></blockquote>
<p><strong>rng</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a>, optional (Default: None)</p>
<blockquote>
<div><p>A random number generator to use as required. If None,
the <code class="docutils literal"><span class="pre">numpy.random</span></code> module functions will be used.</p>
</div></blockquote>
<p><strong>E</strong> : (dimensions, post.n_neurons) array_like, optional (Default: None)</p>
<blockquote>
<div><p>Array of post-population encoders. Providing this tells the solver
to return an array of connection weights rather than decoders.</p>
</div></blockquote>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first"><strong>X</strong> : (n_neurons, dimensions) or (n_neurons, post.n_neurons) ndarray</p>
<blockquote>
<div><p>(n_neurons, dimensions) array of decoders (if <code class="docutils literal"><span class="pre">solver.weights</span></code>
is False) or (n_neurons, post.n_neurons) array of weights
(if <code class="docutils literal"><span class="pre">'solver.weights</span></code> is True).</p>
</div></blockquote>
<p><strong>info</strong> : dict</p>
<blockquote class="last">
<div><p>A dictionary of information about the solver. All dictionaries have
an <code class="docutils literal"><span class="pre">'rmses'</span></code> key that contains RMS errors of the solve.
Other keys are unique to particular solvers.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.solvers.Solver.mul_encoders">
<code class="descname">mul_encoders</code><span class="sig-paren">(</span><em>Y</em>, <em>E</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver.mul_encoders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver.mul_encoders" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that projects signal <code class="docutils literal"><span class="pre">Y</span></code> onto encoders <code class="docutils literal"><span class="pre">E</span></code>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>Y</strong> : ndarray</p>
<blockquote>
<div><p>The signal of interest.</p>
</div></blockquote>
<p><strong>E</strong> : (dimensions, n_neurons) array_like or None</p>
<blockquote>
<div><p>Array of encoders. If None, <code class="docutils literal"><span class="pre">Y</span></code> will be returned unchanged.</p>
</div></blockquote>
<p><strong>copy</strong> : bool, optional (Default: False)</p>
<blockquote class="last">
<div><p>Whether a copy of <code class="docutils literal"><span class="pre">Y</span></code> should be returned if <code class="docutils literal"><span class="pre">E</span></code> is None.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Lstsq">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Lstsq</code><span class="sig-paren">(</span><em>weights=False</em>, <em>rcond=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Lstsq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregularized least-squares solver.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>rcond</strong> : float, optional (Default: 0.01)</p>
<blockquote class="last">
<div><p>Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>rcond</strong></td>
<td>(float) Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.lstsq</span></code></a>).</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqNoise">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqNoise</code><span class="sig-paren">(</span><em>weights=False</em>, <em>noise=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with additive Gaussian white noise.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>noise</strong> : float, optional (Default: 0.1)</p>
<blockquote>
<div><p>Amount of noise, as a fraction of the neuron activity.</p>
</div></blockquote>
<p><strong>solver</strong> : <code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</p>
<blockquote class="last">
<div><p>Subsolver to use for solving the least squares problem.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>noise</strong></td>
<td>(float) Amount of noise, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-even"><td><strong>solver</strong></td>
<td>(<code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>) Subsolver to use for solving the least squares problem.</td>
</tr>
<tr class="row-odd"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqMultNoise">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqMultNoise</code><span class="sig-paren">(</span><em>weights=False</em>, <em>noise=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqMultNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqMultNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with multiplicative white noise.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>noise</strong> : float, optional (Default: 0.1)</p>
<blockquote>
<div><p>Amount of noise, as a fraction of the neuron activity.</p>
</div></blockquote>
<p><strong>solver</strong> : <code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</p>
<blockquote class="last">
<div><p>Subsolver to use for solving the least squares problem.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>noise</strong></td>
<td>(float) Amount of noise, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-odd"><td><strong>solver</strong></td>
<td>(<code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>) Subsolver to use for solving the least squares problem.</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL2</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>reg</strong> : float, optional (Default: 0.1)</p>
<blockquote>
<div><p>Amount of regularization, as a fraction of the neuron activity.</p>
</div></blockquote>
<p><strong>solver</strong> : <code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</p>
<blockquote class="last">
<div><p>Subsolver to use for solving the least squares problem.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reg</strong></td>
<td>(float) Amount of regularization, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-even"><td><strong>solver</strong></td>
<td>(<code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>) Subsolver to use for solving the least squares problem.</td>
</tr>
<tr class="row-odd"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2nz">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL2nz</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization on non-zero components.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>reg</strong> : float, optional (Default: 0.1)</p>
<blockquote>
<div><p>Amount of regularization, as a fraction of the neuron activity.</p>
</div></blockquote>
<p><strong>solver</strong> : <code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</p>
<blockquote class="last">
<div><p>Subsolver to use for solving the least squares problem.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>reg</strong></td>
<td>(float) Amount of regularization, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-odd"><td><strong>solver</strong></td>
<td>(<code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>) Subsolver to use for solving the least squares problem.</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL1">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL1</code><span class="sig-paren">(</span><em>weights=False</em>, <em>l1=0.0001</em>, <em>l2=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L1 and L2 regularization (elastic net).</p>
<p>This method is well suited for creating sparse decoders or weight matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires <a class="reference external" href="http://scikit-learn.org/stable/">scikit-learn</a>.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>l1</strong> : float, optional (Default: 1e-4)</p>
<blockquote>
<div><p>Amount of L1 regularization.</p>
</div></blockquote>
<p><strong>l2</strong> : float, optional (Default: 1e-6)</p>
<blockquote class="last">
<div><p>Amount of L2 regularization.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>l1</strong></td>
<td>(float) Amount of L1 regularization.</td>
</tr>
<tr class="row-even"><td><strong>l2</strong></td>
<td>(float) Amount of L2 regularization.</td>
</tr>
<tr class="row-odd"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqDrop">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqDrop</code><span class="sig-paren">(</span><em>weights=False</em>, <em>drop=0.25</em>, <em>solver1=LstsqL2(reg=0.001</em>, <em>solver=Cholesky(transpose=None)</em>, <em>weights=False)</em>, <em>solver2=LstsqL2(reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em>, <em>weights=False)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqDrop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Find sparser decoders/weights by dropping small values.</p>
<p>This solver first solves for coefficients (decoders/weights) with
L2 regularization, drops those nearest to zero, and retrains remaining.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>drop</strong> : float, optional (Default: 0.25)</p>
<blockquote>
<div><p>Fraction of decoders or weights to set to zero.</p>
</div></blockquote>
<p><strong>solver1</strong> : Solver, optional (Default: <code class="docutils literal"><span class="pre">LstsqL2(reg=0.001)</span></code>)</p>
<blockquote>
<div><p>Solver for finding the initial decoders.</p>
</div></blockquote>
<p><strong>solver2</strong> : Solver, optional (Default: <code class="docutils literal"><span class="pre">LstsqL2(reg=0.1)</span></code>)</p>
<blockquote class="last">
<div><p>Used for re-solving for the decoders after dropout.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>drop</strong></td>
<td>(float) Fraction of decoders or weights to set to zero.</td>
</tr>
<tr class="row-odd"><td><strong>solver1</strong></td>
<td>(Solver) Solver for finding the initial decoders.</td>
</tr>
<tr class="row-even"><td><strong>solver2</strong></td>
<td>(Solver) Used for re-solving for the decoders after dropout.</td>
</tr>
<tr class="row-odd"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Nnls">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Nnls</code><span class="sig-paren">(</span><em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Nnls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver without regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal"><span class="pre">Lstsq</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote class="last">
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NnlsL2</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver with L2 regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal"><span class="pre">LstsqL2</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>reg</strong> : float, optional (Default: 0.1)</p>
<blockquote class="last">
<div><p>Amount of regularization, as a fraction of the neuron activity.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reg</strong></td>
<td>(float) Amount of regularization, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2nz">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NnlsL2nz</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares with L2 regularization on nonzero components.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal"><span class="pre">LstsqL2nz</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote>
<div><p>If False, solve for decoders. If True, solve for weights.</p>
</div></blockquote>
<p><strong>reg</strong> : float, optional (Default: 0.1)</p>
<blockquote class="last">
<div><p>Amount of regularization, as a fraction of the neuron activity.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reg</strong></td>
<td>(float) Amount of regularization, as a fraction of the neuron activity.</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool) If False, solve for decoders. If True, solve for weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NoSolver">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NoSolver</code><span class="sig-paren">(</span><em>values=None</em>, <em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NoSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NoSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually pass in weights, bypassing the decoder solver.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><p class="first"><strong>values</strong> : (n_neurons, n_weights) array_like, optional (Default: None)</p>
<blockquote>
<div><p>The array of decoders or weights to use.
If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <code class="docutils literal"><span class="pre">n_weights</span></code> is the expected
output dimensionality. If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">True</span></code>,
<code class="docutils literal"><span class="pre">n_weights</span></code> is the number of neurons in the post ensemble.
If <code class="docutils literal"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</div></blockquote>
<p><strong>weights</strong> : bool, optional (Default: False)</p>
<blockquote class="last">
<div><p>If False, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as decoders.
If True, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as weights.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Attributes</p>
<table class="table table-bordered">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>values</strong></td>
<td>((n_neurons, n_weights) array_like, optional (Default: None)) The array of decoders or weights to use. If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <code class="docutils literal"><span class="pre">n_weights</span></code> is the expected output dimensionality. If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, <code class="docutils literal"><span class="pre">n_weights</span></code> is the number of neurons in the post ensemble. If <code class="docutils literal"><span class="pre">None</span></code>, which is the default, the solver will return an appropriately sized array of zeros.</td>
</tr>
<tr class="row-even"><td><strong>weights</strong></td>
<td>(bool, optional (Default: False)) If False, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as decoders. If True, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as weights.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="user_guide.html" title="previous chapter (use the left arrow)">User Guide</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="config.html" title="next chapter (use the right arrow)">Setting parameters with Configs</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="config.html" title="Setting parameters with Configs"
             >next</a> |</li>
        <li class="right" >
          <a href="user_guide.html" title="User Guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.6.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" >User Guide</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2013-2017, Applied Brain Research. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>